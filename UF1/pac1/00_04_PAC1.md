[ ... back  ](../README.md)

# Pràctica 1

## Concepte
A mesura que anem escrivint, se'ns mostra la llista de mots que tenen el mateix començament:
![alt text](../images/PAC1/predictiveText.png "Predictive text")

En tot moment (useu l'event _KeyUP_) es valida la sintaxi i es subratllen les paraules errònies:

![alt text](../images/PAC1/spell_check.png "Spell Checking")

Si fem right-click sobre la paraula errònia, es donen les possibles alternatives:
![alt text](../images/PAC1/spell_check_2.png "Spell Checking -  Correcció ")
Cal contemplar dues possibles variacions sobre la paraula errònia:
* eliminar qualsevol de les lletres
* modificar independentment cadascuna de les seves lletres per qualsevol altra lletra.

*Atenció:* Cal que el vostre corrector ignori punts, comes i d'altres caràcters especials.


## Diccionari

[Arxiu de diccionari](dictionary_english.txt)

## Lectura d'un arxiu:

Cal crear l'arxiu "dictionary_english.txt" dins de la carpeta Assets
i incloure-la al projecte des de Visual Studio

```c#
	var file = StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///Assets/dictionary_english.txt")).AsTask().Result;
	string text = FileIO.ReadTextAsync(file).AsTask().Result;
 ```
 
 ## Classe Node ( parcial )
 
 ```c#
    class Node
    {
        private char mLetter;
        private Dictionary<char, Node> mChildren = new Dictionary<char, Node>();
        private List<String> mWords = new List<String>();

		public Node(char pLetter)
        {
            mLetter = pLetter;
        }
 
        public char Letter
        {
            get { return mLetter; }
            set { mLetter = value; }
        }


        public void addChildren(Node pNewChildren)
        {
            mChildren[pNewChildren.Letter] = pNewChildren;
        }

        public bool hasChildren(char pLetter)
        {
            return mChildren.ContainsKey(pLetter);
        }
        public Node getChildren(char pLetter)
        {
            if(mChildren.ContainsKey(pLetter))
            {
                return mChildren[pLetter];
            }
            else
            {
                return null;
            }
        }

        public void AddWords(string pWord)
        {
            mWords.Add(pWord);
        }

        public List<string> GetWords()
        {
            return mWords;
        }

        internal IEnumerable<Node> GetChildren()
        {
            return mChildren.Values;
        }
    }
 ```
 
## RichEditBox
 
 ```c#
 RichEditBox reb;
 
 // lectura del text del RichEditBox
 string text;
 reb.Document.GetText(Windows.UI.Text.TextGetOptions.None, out text);
 

 // permet consultar i modificar la posició final de la selecció 
 reb.Document.Selection.EndPosition 
 // permet consultar i modificar la posició inicial de la selecció 
 reb.Document.Selection.StartPosition
 
 // canviant el text de la selecció
 reb.Document.Selection.SetText("CANVI");
 
 // Fer que no hi hagi selecció (inic==fi) --> cursor normal
 reb.Document.Selection.EndPosition =reb.Document.Selection.StartPosition; 
 
 // Formateig de la selecció
ITextCharacterFormat paragraphFormatting;
 
reb.Document.Selection.StartPosition = start;
reb.Document.Selection.EndPosition = end;
paragraphFormatting = reb.Document.Selection.CharacterFormat;


paragraphFormatting.Underline = UnderlineType.DoubleWave;
paragraphFormatting.ForegroundColor = Colors.Red;
					
```

